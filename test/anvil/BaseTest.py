from dataclasses import dataclass
from typing import Dict
import secrets
import unittest

from eth_typing import ChecksumAddress
import solcx
from web3 import Web3
from web3.types import Wei
from eth_account import Account
from pathlib import Path

@dataclass
class Credentials:
    address: ChecksumAddress
    private_key: str

class BaseTest(unittest.TestCase):
    DEFAULT_MINTER_ALLOWANCE = 1000000

    # Dev account funded with 1M eth generated by Anvil
    FUNDED_DEV_ACCOUNT = Credentials(
        Web3.to_checksum_address('0x70997970c51812dc3a010c7d01b50e0d17dc79c8'),
        '0x59c6995e998f97a5a0044966f0945389dc9e86dae88c7a8412f4603b6b78690d'
    )

    def compile_source_file(self, file_path: str, contract_name: str, version: str) -> Dict:
        """Takes in file path to a Solidity contract, contract name, and optional version params
        and returns a dictionary representing the compiled contract.

        Args:
            file_path (str): Path to contract solidity file to be complied
            contract_name (str): Name of the contract
            version (str): _solidity version

        Returns:
            Dict: Parsed contract containing ABI and Bytecode
        """
        solcx.install_solc(version)
        solcx.set_solc_version(version)
        
        cwd = str(Path.cwd().absolute())
        print(f"Compiling {file_path} under allowed path {cwd}")

        return solcx.compile_files(
            [file_path],
            output_values = ["abi", "bin"],
            import_remappings = {
                "forge-std/": "lib/forge-std/src/",
                "@openzeppelin/": "testlib/openzeppelin-contracts-legacy/"
            },
            allow_paths = ["."]
        )[f'{file_path}:{contract_name}']

    def deploy_contract_from_source(self, file_path: str, contract_name: str, version: str):
        """Takes in a Solidity contract file path, contract name and optional Solidity 
        compiler version, dictionary of libraries to link, arguments for contract
        constructor, and caller address to compile, deploy, and construct a Solidity 
        contract. Returns a web3 contract object representing the deployed contract.

        Args:
            file_path (str): Path to contract solidity file to be complied
            contract_name (str): Name of the contract
            version (str): solidity version 

        Returns:
            Contract: Deployed Contract
        """

        # Compile
        contract_interface = self.compile_source_file(file_path, contract_name, version)

        # Deploy
        tx_hash = self.web3.eth.contract(
            abi=contract_interface['abi'],
            bytecode=solcx.link_code(contract_interface['bin'], {})
        ).constructor().transact()

        self.web3.eth.wait_for_transaction_receipt(tx_hash)

        # Retrieve address and deployed contract
        address = self.web3.eth.get_transaction_receipt(tx_hash)['contractAddress']
        return self.web3.eth.contract(
            address=address,
            abi=contract_interface['abi']
        )

    def build_contract_transaction(self, function_call, credentials: Credentials):
        """Takes in an initialized function call and a designated caller and builds,
        signs, and sends the transaction. Verifies the transaction was received.

        Args:
            function_call (Contract function call): Contract function call
            credentials (Credentials): Credentials to use for signing the transaction
        """
        unsigned_tx = function_call.build_transaction({
            'nonce': self.web3.eth.get_transaction_count(credentials.address),
            'from': credentials.address,
        })
        signed_tx = self.web3.eth.account.sign_transaction(unsigned_tx, credentials.private_key)
        tx_hash = self.web3.eth.send_raw_transaction(signed_tx.rawTransaction)
        self.web3.eth.wait_for_transaction_receipt(tx_hash)

    def generate_new_credentials(self) -> Credentials:
        """Generate new address and key pair. Funds it with 10 ETH 

        Returns:
            Credentials: Created address / key pair
        """
        account = Account.from_key("0x" + secrets.token_hex(32))
        self.send_eth(account.address, Wei(10000000000000000000)) # 10 ETH
        return Credentials(account.address, account.key)

    def send_eth(self, address: ChecksumAddress, amount: Wei) -> None:
        """Creates a transaction for sending eth from dev account to given address

        Args:
            address (ChecksumAddress): address to fund
            amount (Wei): amount in Wei
        """
        unsigned_tx = {
            "from": self.FUNDED_DEV_ACCOUNT.address,
            "to": address,
            "value": amount,
            'nonce': self.web3.eth.get_transaction_count(self.FUNDED_DEV_ACCOUNT.address),
            'gasPrice': self.web3.eth.gas_price
        }

        unsigned_tx['gas'] = self.web3.eth.estimate_gas(unsigned_tx)
        signed_tx = self.web3.eth.account.sign_transaction(unsigned_tx, self.FUNDED_DEV_ACCOUNT.private_key)
        tx_hash = self.web3.eth.send_raw_transaction(signed_tx.rawTransaction)
        self.web3.eth.wait_for_transaction_receipt(tx_hash)
        assert self.web3.eth.get_balance(address) == amount

    def deploy_usdc_contract(self, minter: Credentials):
        """Deploy USDC contract. Use the provided credentials to set master minter address

        Args:
            minter (Credentials): minter address

        Returns:
            Contract: created contract
        """
        # Deploy and initialize USDC on ETH
        usdc_contract = self.deploy_contract_from_source(
            'lib/centre-tokens/contracts/v2/FiatTokenV2_1.sol',
            'FiatTokenV2_1',
            '0.6.12'
        )

        usdc_contract.functions.initialize(
            "USDC",
            "USDC",
            "USDC",
            0,
            minter.address,
            self.web3.eth.account.create().address,
            self.web3.eth.account.create().address,
            minter.address
        ).transact()

        self.build_contract_transaction(
            usdc_contract.functions.configureMinter(minter.address, self.DEFAULT_MINTER_ALLOWANCE),
            minter
        )

        return usdc_contract

    def setUp(self) -> None:
        # Connect to node
        self.web3 = Web3(Web3.HTTPProvider('http://0.0.0.0:8545'))
        assert self.web3.is_connected()
